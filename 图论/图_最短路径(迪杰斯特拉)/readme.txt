迪杰斯特拉算法（Dijkstra）

	典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。
	主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。 属于贪心算法
	
	算法思想：设G=(V,E)是一个带权图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。
	
例如：图G 有顶点信息为(v1,v2,v3,v4,v5,v6) 边的权重分别为
v1 - v2 7
v1 - v3 9
v1 - v6 14
v2 - v4 15
v2 - v3 10
v3 - v4 11
v3 - v6 2
v4 - v5 6
v5 - v6 9
假设图G从v0顶点开始搜索，演示如下：
步骤1、将v1加入到已发现顶点集合S{v1}，遍历所有与S{v1}相连的边，
       所有与S{v1}相连的顶点进行修改距离
步骤2、遍历与集合S相连的所有边, 找去其中权重最小的边，
       将另一个顶点加入到集合S中，从v2,v3,v6中选出v2,S{v1,v2}， 更新所有与v2直连的顶点，对比距离d(i) > d(2) + E(2,i)，则更新i的距离
步骤3、遍历与集合S相连的所有边, 找去其中权重最小的边，
       将另一个顶点加入到集合S中，从v3,v4,v6中选出v3,S{v1,v2,v3}, 对比距离d(i) > d(3) + E(3,i), 则更新i的距离
步骤4、遍历与集合S相连的所有边, 找去其中权重最小的边，
       将另一个顶点加入到集合S中，从v4,v6中选出v6,S{v1,v2,v3,v6}, 对比距离d(i) > d(6) + E(6,i), 则更新i的距离
步骤5、遍历与集合S相连的所有边, 找去其中权重最小的边，
       将另一个顶点加入到集合S中，从v4,v5中选出v5,S{v1,v2,v3,v6,v5}, 对比距离d(i) > d(5) + E(5,i), 则更新i的距离
步骤6、遍历与集合S相连的所有边, 找去其中权重最小的边，
       将另一个顶点加入到集合S中，从v4中选出v4,S{v1,v2,v3,v6,v5,v4}, 对比距离d(i) > d(4) + E(4,i), 则更新i的距离
------+-----------+-----------+-----------+---------------+------------------+---------------+--------------------
      |    v1     |    v2     |    v3     |        v4     |        v5        |      v6       | S
------+-----------+-----------+-----------+---------------+------------------+---------------+--------------------
步骤1 | (v1,v1) 0 | (v1,v2) 7 | (v1,v3) 9 |       Na      |        Na        | (v1,v6) 14    | {v1}
------+-----------+-----------+-----------+---------------+------------------+---------------+--------------------
步骤2 | (v1,v1) 0 | (v1,v2) 7 | (v1,v3) 9 | (v1,v2,v4) 22 |        Na        | (v1,v6) 14    | {v1,v2}
------+-----------+-----------+-----------+---------------+------------------+---------------+--------------------
步骤3 | (v1,v1) 0 | (v1,v2) 7 | (v1,v3) 9 | (v1,v3,v4) 20 |        Na        | (v1,v3,v6) 11 | {v1,v2,v3}
------+-----------+-----------+-----------+---------------+------------------+---------------+--------------------
步骤4 | (v1,v1) 0 | (v1,v2) 7 | (v1,v3) 9 | (v1,v3,v4) 20 | (v1,v3,v6,v5) 20 | (v1,v3,v6) 11 | {v1,v2,v3,v6}
------+-----------+-----------+-----------+---------------+------------------+---------------+--------------------
步骤5 | (v1,v1) 0 | (v1,v2) 7 | (v1,v3) 9 | (v1,v3,v4) 20 | (v1,v3,v6,v5) 20 | (v1,v3,v6) 11 | {v1,v2,v3,v6,v5}
------+-----------+-----------+-----------+---------------+------------------+---------------+--------------------
步骤6 | (v1,v1) 0 | (v1,v2) 7 | (v1,v3) 9 | (v1,v3,v4) 20 | (v1,v3,v6,v5) 20 | (v1,v3,v6) 11 | {v1,v2,v3,v6,v5,v4}
------+-----------+-----------+-----------+---------------+------------------+---------------+--------------------


测试效果：
$ ./graph_dijkstra 
输入图的结点数:6
输入图的边数:9
输入结点序列（例如：v1 v2 v3）：
v1 v2 v3 v4 v5 v6
输入边信息（例如：v1 - v2 5）：
v1 - v2 7
v1 - v3 9
v1 - v6 14
v2 - v4 15
v2 - v3 10
v3 - v4 11
v3 - v6 2
v4 - v5 6
v5 - v6 9
输出图的链接信息：
v1 ->5(14)->2(9)->1(7)
v2 ->2(10)->3(15)->0(7)
v3 ->5(2)->3(11)->1(10)->0(9)
v4 ->4(6)->2(11)->1(15)
v5 ->5(9)->3(6)
v6 ->4(9)->2(2)->0(14)
-----------
0 - 0(0)
0 - 1(7)
0 - 2(9)
0 - 3(20)
0 - 4(20)
0 - 5(11)

./graph_dijkstra 
输入图的结点数:4
输入图的边数:5
输入结点序列（例如：v1 v2 v3）：
v1 v2 v3 v4
输入边信息（例如：v1 - v2 5）：
v1 - v2 1
v1 - v4 17
v1 - v3 9
v2 - v4 3
v3 - v4 2
输出图的链接信息：
v1 ->2(9)->3(17)->1(1)
v2 ->3(3)->0(1)
v3 ->3(2)->0(9)
v4 ->2(2)->1(3)->0(17)
-------------
0 - 0(0)
0 - 1(1)
0 - 2(6)
0 - 3(4)

